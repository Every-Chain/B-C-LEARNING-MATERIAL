### 事件

- 在编程领域里面其实是很常用的一些做法
- `事件是以太坊的日志功能`: 当发生某个动作或者某个数据的条件变化的时候,可以来触发一个动作，这个触发的动作称之为**事件**
- `设置的事件会被触发`: 在以太坊智能合约的编程里面，可以通过event关键字来定义一个事件，举例：
    * `event Deposit(address from, uint value);`
    * 事件是没有方法体的, 使用的event关键字，有参数
    * 假如我们写了一个转账程序，事件是以太坊的日志功能，当合约某个方法被调用(这是一个动作)，也就意味着某个数据发生了变化
    * 在以太坊中会记录这个日志，并抛出一个事件，外部的客户端程序可以监听被定义的事件
    * 比如：我们的钱包客户端可以监听存款转账事件，从而显示相应的提示消息或界面提示框
- `外部可以监听事件的发生`: 事件是在智能合约里面做了这样的一个定义，但是它的使用是要在外部区域使用的
    * 比如web3.js写的一个外部客户端程序
    * 在外部的客户端程序里面，我们来通过这个事件的一个监听调用来触发相应的外部的一些处理

### 接口

- 接口和合约中的抽象方法非常类似，但也不同
    * 接口本身通过interface关键字定义
    * 接口不能再集成其他的合约
    * 接口中只放方法，不放属性变量且没有方法体
- 所谓的接口就是一组可以面向外部的共同的调用方法
- 对于外部程序来说，如果继承了这个接口，那么这个合约一定包含接口中的方法和实现
- 用于代码封装，举例如下

```js
pragma solidity ^0.4.19;

interface Cash {
    function receive(address recipient, uint amount) external;
    function getRemain(address cashAccount) external;
}
```

### 函数修改器

- 它的作用是 函数执行的修饰约束
- 什么是修饰约束?
    * 当我们调用智能合约中的方法的时候，这个方法可能需要具备某个条件才能被执行
    * 下面是个具体的例子

```js
pragma solidity ^0.4.19;

contract FunctionModifierTest {
    // 这里有一个构造方法，把调用者的地址(合约部署者的地址)
    // 构造方法会在合约部署的时候会被执行一次，把部署者的账户地址存在myself变量里
    function FunctionModifierTest() public {myself = msg.sender;}

    address myself;
    bool frozen;
    // 使用modifier声明一个函数修改器
    // 函数修改器类似方法一样，可以这样声明定义
    // 函数当前调用地址如果不是部署者则会报异常
    // 函数修改器类似一种语法糖，封装了一些条件判断而已
    // 如果不使用函数修改器，则需要加一些判断，函数修改器让代码更加简洁
    modifier onlyOwner {
        assert(msg.sender != myself);
        _;
    }

    // 当我们调用另一个方法close关闭合约，将合约中的frozen属性变量编程true表示关闭
    // 任何调用者都可以关闭肯定是不行的，我们需要对这个方法做一个约束，用了上面onlyOwner的函数修改器
    function close() public onlyOwner {
        frozen = true;
    }
}

```

### 小讨论

- 事件的实现是什么原理?
- 接口的主要特点是什么?
- 函数修改器在编译层面是什么原理?